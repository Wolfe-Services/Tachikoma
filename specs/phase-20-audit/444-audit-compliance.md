# 444 - Audit Compliance

**Phase:** 20 - Audit System
**Spec ID:** 444
**Status:** Planned
**Dependencies:** 435-audit-query, 437-audit-export
**Estimated Context:** ~12% of Sonnet window

---

## Objective

Implement compliance reporting capabilities for audit data, supporting common compliance frameworks (SOC 2, ISO 27001, GDPR).

---

## Acceptance Criteria

- [x] Compliance report generation
- [x] Framework-specific report templates
- [x] Control mapping
- [x] Evidence collection
- [x] Compliance dashboard data

---

## Implementation Details

### 1. Compliance Types (src/compliance.rs)

```rust
//! Compliance framework support.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Supported compliance frameworks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ComplianceFramework {
    /// SOC 2 Type II.
    Soc2,
    /// ISO 27001.
    Iso27001,
    /// GDPR.
    Gdpr,
    /// HIPAA.
    Hipaa,
    /// PCI DSS.
    PciDss,
    /// Custom framework.
    Custom,
}

impl ComplianceFramework {
    /// Get framework display name.
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Soc2 => "SOC 2 Type II",
            Self::Iso27001 => "ISO 27001",
            Self::Gdpr => "GDPR",
            Self::Hipaa => "HIPAA",
            Self::PciDss => "PCI DSS",
            Self::Custom => "Custom",
        }
    }
}

/// A compliance control.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceControl {
    /// Control identifier (e.g., "CC6.1").
    pub id: String,
    /// Control name.
    pub name: String,
    /// Control description.
    pub description: String,
    /// Framework this control belongs to.
    pub framework: ComplianceFramework,
    /// Category within the framework.
    pub category: String,
    /// Audit event categories that provide evidence.
    pub evidence_categories: Vec<crate::AuditCategory>,
    /// Required actions for evidence.
    pub evidence_actions: Vec<String>,
}

/// Compliance evidence item.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceEvidence {
    /// Control this evidence supports.
    pub control_id: String,
    /// Type of evidence.
    pub evidence_type: EvidenceType,
    /// Description of the evidence.
    pub description: String,
    /// Related audit event IDs.
    pub event_ids: Vec<String>,
    /// Time range covered.
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    /// Event count.
    pub event_count: u64,
}

/// Type of compliance evidence.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EvidenceType {
    /// Audit log evidence.
    AuditLog,
    /// Configuration evidence.
    Configuration,
    /// Access control evidence.
    AccessControl,
    /// Change management evidence.
    ChangeManagement,
    /// Incident response evidence.
    IncidentResponse,
}

/// Control compliance status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ControlStatus {
    /// Control is fully compliant.
    Compliant,
    /// Control is partially compliant.
    PartiallyCompliant,
    /// Control is not compliant.
    NonCompliant,
    /// Not enough data to determine.
    Indeterminate,
    /// Not applicable.
    NotApplicable,
}

/// Compliance report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    /// Report identifier.
    pub id: String,
    /// Framework being reported on.
    pub framework: ComplianceFramework,
    /// Report title.
    pub title: String,
    /// Report period start.
    pub period_start: DateTime<Utc>,
    /// Report period end.
    pub period_end: DateTime<Utc>,
    /// Generated at.
    pub generated_at: DateTime<Utc>,
    /// Generated by.
    pub generated_by: String,
    /// Control assessments.
    pub controls: Vec<ControlAssessment>,
    /// Summary statistics.
    pub summary: ComplianceSummary,
}

/// Assessment of a single control.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ControlAssessment {
    /// Control being assessed.
    pub control: ComplianceControl,
    /// Assessment status.
    pub status: ControlStatus,
    /// Evidence collected.
    pub evidence: Vec<ComplianceEvidence>,
    /// Findings/notes.
    pub findings: Vec<String>,
    /// Recommendations.
    pub recommendations: Vec<String>,
}

/// Compliance summary.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceSummary {
    pub total_controls: u32,
    pub compliant: u32,
    pub partially_compliant: u32,
    pub non_compliant: u32,
    pub indeterminate: u32,
    pub not_applicable: u32,
    pub compliance_score: f64,
}

impl ComplianceSummary {
    /// Calculate summary from assessments.
    pub fn from_assessments(assessments: &[ControlAssessment]) -> Self {
        let mut summary = Self {
            total_controls: assessments.len() as u32,
            compliant: 0,
            partially_compliant: 0,
            non_compliant: 0,
            indeterminate: 0,
            not_applicable: 0,
            compliance_score: 0.0,
        };

        for assessment in assessments {
            match assessment.status {
                ControlStatus::Compliant => summary.compliant += 1,
                ControlStatus::PartiallyCompliant => summary.partially_compliant += 1,
                ControlStatus::NonCompliant => summary.non_compliant += 1,
                ControlStatus::Indeterminate => summary.indeterminate += 1,
                ControlStatus::NotApplicable => summary.not_applicable += 1,
            }
        }

        let applicable = summary.total_controls - summary.not_applicable;
        if applicable > 0 {
            let score = (summary.compliant as f64 + summary.partially_compliant as f64 * 0.5)
                / applicable as f64;
            summary.compliance_score = (score * 100.0).round();
        }

        summary
    }
}
```

### 2. Control Library (src/control_library.rs)

```rust
//! Pre-defined compliance controls.

use crate::compliance::*;
use crate::AuditCategory;
use std::collections::HashMap;

/// Library of compliance controls.
pub struct ControlLibrary {
    controls: HashMap<String, ComplianceControl>,
}

impl ControlLibrary {
    /// Create a new library with default controls.
    pub fn new() -> Self {
        let mut library = Self {
            controls: HashMap::new(),
        };
        library.load_soc2_controls();
        library.load_gdpr_controls();
        library
    }

    fn load_soc2_controls(&mut self) {
        // SOC 2 Common Criteria controls
        let controls = vec![
            ComplianceControl {
                id: "CC6.1".to_string(),
                name: "Logical Access Security".to_string(),
                description: "The entity implements logical access security software, infrastructure, and architectures over protected information assets".to_string(),
                framework: ComplianceFramework::Soc2,
                category: "Logical and Physical Access Controls".to_string(),
                evidence_categories: vec![AuditCategory::Authentication, AuditCategory::Authorization],
                evidence_actions: vec!["login".to_string(), "logout".to_string(), "access_granted".to_string(), "access_denied".to_string()],
            },
            ComplianceControl {
                id: "CC6.2".to_string(),
                name: "Access Provisioning".to_string(),
                description: "Prior to issuing system credentials, the entity registers and authorizes new internal and external users".to_string(),
                framework: ComplianceFramework::Soc2,
                category: "Logical and Physical Access Controls".to_string(),
                evidence_categories: vec![AuditCategory::UserManagement],
                evidence_actions: vec!["user_created".to_string(), "role_assigned".to_string()],
            },
            ComplianceControl {
                id: "CC6.3".to_string(),
                name: "Access Removal".to_string(),
                description: "The entity removes access to protected information assets when appropriate".to_string(),
                framework: ComplianceFramework::Soc2,
                category: "Logical and Physical Access Controls".to_string(),
                evidence_categories: vec![AuditCategory::UserManagement],
                evidence_actions: vec!["user_deleted".to_string(), "user_disabled".to_string(), "role_revoked".to_string()],
            },
            ComplianceControl {
                id: "CC7.1".to_string(),
                name: "System Operations".to_string(),
                description: "The entity uses detection and monitoring procedures to identify changes to configurations".to_string(),
                framework: ComplianceFramework::Soc2,
                category: "System Operations".to_string(),
                evidence_categories: vec![AuditCategory::Configuration, AuditCategory::System],
                evidence_actions: vec!["config_updated".to_string(), "config_created".to_string()],
            },
            ComplianceControl {
                id: "CC7.2".to_string(),
                name: "Security Monitoring".to_string(),
                description: "The entity monitors system components for anomalies".to_string(),
                framework: ComplianceFramework::Soc2,
                category: "System Operations".to_string(),
                evidence_categories: vec![AuditCategory::Security],
                evidence_actions: vec!["suspicious_activity".to_string(), "security_violation".to_string()],
            },
        ];

        for control in controls {
            self.controls.insert(control.id.clone(), control);
        }
    }

    fn load_gdpr_controls(&mut self) {
        let controls = vec![
            ComplianceControl {
                id: "GDPR-30".to_string(),
                name: "Records of Processing Activities".to_string(),
                description: "Maintain records of data processing activities".to_string(),
                framework: ComplianceFramework::Gdpr,
                category: "Documentation".to_string(),
                evidence_categories: vec![AuditCategory::DataTransfer],
                evidence_actions: vec!["data_exported".to_string(), "data_imported".to_string()],
            },
            ComplianceControl {
                id: "GDPR-32".to_string(),
                name: "Security of Processing".to_string(),
                description: "Implement appropriate technical and organizational measures".to_string(),
                framework: ComplianceFramework::Gdpr,
                category: "Security".to_string(),
                evidence_categories: vec![AuditCategory::Authentication, AuditCategory::Security],
                evidence_actions: vec!["login".to_string(), "login_failed".to_string()],
            },
            ComplianceControl {
                id: "GDPR-33".to_string(),
                name: "Data Breach Notification".to_string(),
                description: "Notify supervisory authority of data breaches".to_string(),
                framework: ComplianceFramework::Gdpr,
                category: "Breach Response".to_string(),
                evidence_categories: vec![AuditCategory::Security],
                evidence_actions: vec!["data_breach".to_string(), "security_violation".to_string()],
            },
        ];

        for control in controls {
            self.controls.insert(control.id.clone(), control);
        }
    }

    /// Get a control by ID.
    pub fn get(&self, id: &str) -> Option<&ComplianceControl> {
        self.controls.get(id)
    }

    /// Get all controls for a framework.
    pub fn by_framework(&self, framework: ComplianceFramework) -> Vec<&ComplianceControl> {
        self.controls
            .values()
            .filter(|c| c.framework == framework)
            .collect()
    }

    /// Add a custom control.
    pub fn add(&mut self, control: ComplianceControl) {
        self.controls.insert(control.id.clone(), control);
    }
}

impl Default for ControlLibrary {
    fn default() -> Self {
        Self::new()
    }
}
```

### 3. Report Generator (src/report_generator.rs)

```rust
//! Compliance report generation.

use crate::compliance::*;
use crate::control_library::ControlLibrary;
use chrono::{DateTime, Utc};
use parking_lot::Mutex;
use rusqlite::Connection;
use std::sync::Arc;

/// Report generator configuration.
#[derive(Debug, Clone)]
pub struct ReportConfig {
    /// Minimum events required for compliant status.
    pub min_evidence_count: u64,
    /// Include event samples in evidence.
    pub include_samples: bool,
    /// Maximum samples per control.
    pub max_samples: u32,
}

impl Default for ReportConfig {
    fn default() -> Self {
        Self {
            min_evidence_count: 10,
            include_samples: true,
            max_samples: 5,
        }
    }
}

/// Compliance report generator.
pub struct ReportGenerator {
    conn: Arc<Mutex<Connection>>,
    library: ControlLibrary,
    config: ReportConfig,
}

impl ReportGenerator {
    /// Create a new report generator.
    pub fn new(
        conn: Arc<Mutex<Connection>>,
        library: ControlLibrary,
        config: ReportConfig,
    ) -> Self {
        Self { conn, library, config }
    }

    /// Generate a compliance report.
    pub fn generate(
        &self,
        framework: ComplianceFramework,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
        generated_by: &str,
    ) -> Result<ComplianceReport, ReportError> {
        let controls = self.library.by_framework(framework);
        let mut assessments = Vec::new();

        for control in controls {
            let assessment = self.assess_control(control, period_start, period_end)?;
            assessments.push(assessment);
        }

        let summary = ComplianceSummary::from_assessments(&assessments);

        Ok(ComplianceReport {
            id: uuid::Uuid::new_v4().to_string(),
            framework,
            title: format!("{} Compliance Report", framework.display_name()),
            period_start,
            period_end,
            generated_at: Utc::now(),
            generated_by: generated_by.to_string(),
            controls: assessments,
            summary,
        })
    }

    fn assess_control(
        &self,
        control: &ComplianceControl,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
    ) -> Result<ControlAssessment, ReportError> {
        let conn = self.conn.lock();

        // Build query for evidence
        let categories: Vec<String> = control.evidence_categories
            .iter()
            .map(|c| c.to_string())
            .collect();

        let placeholders = categories.iter().map(|_| "?").collect::<Vec<_>>().join(",");
        let sql = format!(
            "SELECT id, timestamp, category, action FROM audit_events
             WHERE category IN ({}) AND timestamp >= ? AND timestamp < ?
             ORDER BY timestamp DESC",
            placeholders
        );

        let mut params: Vec<Box<dyn rusqlite::ToSql>> = categories
            .iter()
            .map(|c| Box::new(c.clone()) as Box<dyn rusqlite::ToSql>)
            .collect();
        params.push(Box::new(period_start.to_rfc3339()));
        params.push(Box::new(period_end.to_rfc3339()));

        let param_refs: Vec<&dyn rusqlite::ToSql> = params.iter().map(|p| p.as_ref()).collect();

        let mut stmt = conn.prepare(&sql)?;
        let mut event_ids = Vec::new();
        let mut event_count = 0u64;

        let rows = stmt.query_map(param_refs.as_slice(), |row| {
            Ok((row.get::<_, String>(0)?, row.get::<_, String>(3)?))
        })?;

        for row in rows {
            let (id, action) = row?;
            event_count += 1;

            // Check if action matches required evidence
            let action_lower = action.to_lowercase();
            if control.evidence_actions.iter().any(|a| action_lower.contains(&a.to_lowercase())) {
                if self.config.include_samples && event_ids.len() < self.config.max_samples as usize {
                    event_ids.push(id);
                }
            }
        }

        // Determine status
        let status = if event_count >= self.config.min_evidence_count {
            ControlStatus::Compliant
        } else if event_count > 0 {
            ControlStatus::PartiallyCompliant
        } else {
            ControlStatus::Indeterminate
        };

        let evidence = vec![ComplianceEvidence {
            control_id: control.id.clone(),
            evidence_type: EvidenceType::AuditLog,
            description: format!("{} audit events in period", event_count),
            event_ids,
            period_start,
            period_end,
            event_count,
        }];

        let mut findings = Vec::new();
        let mut recommendations = Vec::new();

        if event_count < self.config.min_evidence_count {
            findings.push(format!(
                "Insufficient audit evidence ({} events, {} required)",
                event_count, self.config.min_evidence_count
            ));
            recommendations.push("Increase audit logging for this control area".to_string());
        }

        Ok(ControlAssessment {
            control: control.clone(),
            status,
            evidence,
            findings,
            recommendations,
        })
    }
}

/// Report generation error.
#[derive(Debug, thiserror::Error)]
pub enum ReportError {
    #[error("database error: {0}")]
    Database(#[from] rusqlite::Error),
    #[error("configuration error: {0}")]
    Config(String),
}
```

---

## Testing Requirements

1. SOC 2 controls are complete
2. Evidence collection queries correctly
3. Status determination is accurate
4. Summary calculations are correct
5. Report serialization works

---

## Related Specs

- Depends on: [435-audit-query.md](435-audit-query.md), [437-audit-export.md](437-audit-export.md)
- Next: [445-audit-alerting.md](445-audit-alerting.md)

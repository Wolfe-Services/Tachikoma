# 097 - Loop Iteration

**Phase:** 5 - Ralph Loop Runner
**Spec ID:** 097
**Status:** Planned
**Dependencies:** 096-loop-runner-core
**Estimated Context:** ~10% of Sonnet window

---

## Objective

Implement the iteration logic for the Ralph Loop - the core unit of work that executes a single cycle of sending a prompt to Claude Code, monitoring execution, and collecting results.

---

## Acceptance Criteria

- [x] `Iteration` struct with complete lifecycle
- [x] Pre-iteration hooks execution
- [x] Claude Code invocation with proper argument handling
- [x] Output capture and parsing
- [x] Progress detection logic
- [x] Post-iteration hooks execution
- [x] Iteration result aggregation
- [x] Timeout handling for long-running iterations

---

## Implementation Details

### 1. Iteration Types (src/iteration/types.rs)

```rust
//! Iteration type definitions.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// A single iteration of the Ralph loop.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Iteration {
    /// Unique iteration number within the loop.
    pub number: u32,
    /// Start timestamp.
    pub started_at: DateTime<Utc>,
    /// End timestamp (if completed).
    pub ended_at: Option<DateTime<Utc>>,
    /// Current status.
    pub status: IterationStatus,
    /// The prompt sent.
    pub prompt: String,
    /// Result of the iteration.
    pub result: Option<IterationResult>,
    /// Metadata.
    pub metadata: HashMap<String, String>,
}

/// Status of an iteration.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum IterationStatus {
    /// Iteration is pending.
    Pending,
    /// Running pre-iteration hooks.
    PreHooks,
    /// Claude Code is executing.
    Executing,
    /// Running post-iteration hooks.
    PostHooks,
    /// Completed successfully.
    Completed,
    /// Failed with error.
    Failed,
    /// Timed out.
    TimedOut,
    /// Skipped.
    Skipped,
}

/// Result of a completed iteration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IterationResult {
    /// Exit code from Claude Code.
    pub exit_code: i32,
    /// Captured stdout.
    pub stdout: String,
    /// Captured stderr.
    pub stderr: String,
    /// Files that were modified.
    pub files_modified: Vec<PathBuf>,
    /// Files that were created.
    pub files_created: Vec<PathBuf>,
    /// Files that were deleted.
    pub files_deleted: Vec<PathBuf>,
    /// Whether tests were run.
    pub tests_run: bool,
    /// Test results if tests were run.
    pub test_results: Option<TestResults>,
    /// Detected context usage percentage.
    pub context_usage_percent: u8,
    /// Whether progress was detected.
    pub progress_detected: bool,
    /// Summary generated by Claude.
    pub summary: Option<String>,
    /// Duration in milliseconds.
    pub duration_ms: u64,
}

/// Test execution results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResults {
    /// Total tests run.
    pub total: u32,
    /// Tests passed.
    pub passed: u32,
    /// Tests failed.
    pub failed: u32,
    /// Tests skipped.
    pub skipped: u32,
    /// Individual test details.
    pub details: Vec<TestDetail>,
}

impl TestResults {
    /// Did all tests pass?
    pub fn all_passed(&self) -> bool {
        self.failed == 0
    }

    /// Success rate as a percentage.
    pub fn success_rate(&self) -> f64 {
        if self.total == 0 {
            100.0
        } else {
            (self.passed as f64 / self.total as f64) * 100.0
        }
    }
}

/// Detail of a single test.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestDetail {
    /// Test name.
    pub name: String,
    /// Test status.
    pub status: TestStatus,
    /// Duration in milliseconds.
    pub duration_ms: u64,
    /// Error message if failed.
    pub error: Option<String>,
}

/// Status of a test.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TestStatus {
    Passed,
    Failed,
    Skipped,
    Error,
}

impl Iteration {
    /// Create a new iteration.
    pub fn new(number: u32, prompt: String) -> Self {
        Self {
            number,
            started_at: Utc::now(),
            ended_at: None,
            status: IterationStatus::Pending,
            prompt,
            result: None,
            metadata: HashMap::new(),
        }
    }

    /// Get duration if completed.
    pub fn duration(&self) -> Option<chrono::Duration> {
        self.ended_at.map(|end| end - self.started_at)
    }

    /// Mark as completed.
    pub fn complete(&mut self, result: IterationResult) {
        self.ended_at = Some(Utc::now());
        self.status = IterationStatus::Completed;
        self.result = Some(result);
    }

    /// Mark as failed.
    pub fn fail(&mut self, error: &str) {
        self.ended_at = Some(Utc::now());
        self.status = IterationStatus::Failed;
        self.metadata.insert("error".to_string(), error.to_string());
    }

    /// Mark as timed out.
    pub fn timeout(&mut self) {
        self.ended_at = Some(Utc::now());
        self.status = IterationStatus::TimedOut;
    }
}
```

### 2. Iteration Executor (src/iteration/executor.rs)

```rust
//! Iteration execution logic.

use super::types::{Iteration, IterationResult, IterationStatus, TestResults};
use crate::error::{LoopError, LoopResult};
use crate::session::Session;

use std::path::Path;
use std::time::Duration;
use tokio::process::Command;
use tokio::time::timeout;
use tracing::{debug, info, instrument, warn};

/// Configuration for iteration execution.
#[derive(Debug, Clone)]
pub struct IterationConfig {
    /// Timeout for the entire iteration.
    pub timeout: Duration,
    /// Working directory.
    pub working_dir: std::path::PathBuf,
    /// Environment variables to set.
    pub env_vars: std::collections::HashMap<String, String>,
    /// Whether to capture file changes.
    pub track_file_changes: bool,
    /// Whether to parse test output.
    pub parse_tests: bool,
}

impl Default for IterationConfig {
    fn default() -> Self {
        Self {
            timeout: Duration::from_secs(1800), // 30 minutes
            working_dir: std::path::PathBuf::from("."),
            env_vars: std::collections::HashMap::new(),
            track_file_changes: true,
            parse_tests: true,
        }
    }
}

/// Executes individual iterations.
pub struct IterationExecutor {
    config: IterationConfig,
    file_tracker: Option<FileChangeTracker>,
}

impl IterationExecutor {
    /// Create a new executor.
    pub fn new(config: IterationConfig) -> Self {
        let file_tracker = if config.track_file_changes {
            Some(FileChangeTracker::new(&config.working_dir))
        } else {
            None
        };

        Self {
            config,
            file_tracker,
        }
    }

    /// Execute an iteration.
    #[instrument(skip(self, iteration, session), fields(iteration = iteration.number))]
    pub async fn execute(
        &mut self,
        iteration: &mut Iteration,
        session: &mut Session,
    ) -> LoopResult<IterationResult> {
        info!("Executing iteration {}", iteration.number);

        // Take file snapshot before execution
        if let Some(tracker) = &mut self.file_tracker {
            tracker.snapshot().await?;
        }

        iteration.status = IterationStatus::Executing;

        // Execute with timeout
        let execution_result = timeout(
            self.config.timeout,
            self.execute_inner(iteration, session),
        )
        .await;

        match execution_result {
            Ok(Ok(result)) => {
                iteration.complete(result.clone());
                Ok(result)
            }
            Ok(Err(e)) => {
                iteration.fail(&e.to_string());
                Err(e)
            }
            Err(_) => {
                warn!("Iteration {} timed out", iteration.number);
                iteration.timeout();
                Err(LoopError::IterationTimeout {
                    iteration: iteration.number,
                    timeout: self.config.timeout,
                })
            }
        }
    }

    /// Inner execution logic.
    async fn execute_inner(
        &mut self,
        iteration: &Iteration,
        session: &mut Session,
    ) -> LoopResult<IterationResult> {
        let start = std::time::Instant::now();

        // Send prompt to session
        let response = session.execute_prompt(&iteration.prompt).await?;

        // Detect file changes
        let (files_modified, files_created, files_deleted) = if let Some(tracker) = &mut self.file_tracker {
            tracker.detect_changes().await?
        } else {
            (vec![], vec![], vec![])
        };

        // Parse test results if present
        let test_results = if self.config.parse_tests {
            self.parse_test_output(&response.stdout).await
        } else {
            None
        };

        // Detect progress
        let progress_detected = self.detect_progress(
            &files_modified,
            &files_created,
            &files_deleted,
            &test_results,
        );

        // Get context usage
        let context_usage = session.get_context_usage().await?;

        let duration_ms = start.elapsed().as_millis() as u64;

        Ok(IterationResult {
            exit_code: response.exit_code,
            stdout: response.stdout,
            stderr: response.stderr,
            files_modified,
            files_created,
            files_deleted,
            tests_run: test_results.is_some(),
            test_results,
            context_usage_percent: context_usage,
            progress_detected,
            summary: self.extract_summary(&response.stdout),
            duration_ms,
        })
    }

    /// Parse test output to extract results.
    async fn parse_test_output(&self, output: &str) -> Option<TestResults> {
        // Look for common test output patterns
        let patterns = [
            // Rust/cargo test
            (r"test result: (\w+)\. (\d+) passed; (\d+) failed; (\d+) ignored", "cargo"),
            // Jest/npm test
            (r"Tests:\s+(\d+) passed, (\d+) failed, (\d+) total", "jest"),
            // pytest
            (r"(\d+) passed, (\d+) failed, (\d+) skipped", "pytest"),
        ];

        for (pattern, _framework) in patterns {
            if let Some(captures) = regex::Regex::new(pattern)
                .ok()
                .and_then(|re| re.captures(output))
            {
                // Parse based on pattern matches
                // This is simplified - real implementation would be more robust
                return Some(TestResults {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    skipped: 0,
                    details: vec![],
                });
            }
        }

        None
    }

    /// Detect if progress was made.
    fn detect_progress(
        &self,
        modified: &[std::path::PathBuf],
        created: &[std::path::PathBuf],
        deleted: &[std::path::PathBuf],
        test_results: &Option<TestResults>,
    ) -> bool {
        // Progress if any files changed
        if !modified.is_empty() || !created.is_empty() || !deleted.is_empty() {
            return true;
        }

        // Progress if tests improved
        if let Some(results) = test_results {
            if results.all_passed() {
                return true;
            }
        }

        false
    }

    /// Extract a summary from Claude's output.
    fn extract_summary(&self, output: &str) -> Option<String> {
        // Look for summary markers in output
        let summary_markers = ["## Summary", "### Summary", "Summary:"];

        for marker in summary_markers {
            if let Some(idx) = output.find(marker) {
                let start = idx + marker.len();
                let summary: String = output[start..]
                    .lines()
                    .take(5)
                    .collect::<Vec<_>>()
                    .join("\n")
                    .trim()
                    .to_string();

                if !summary.is_empty() {
                    return Some(summary);
                }
            }
        }

        None
    }
}

/// Tracks file system changes between snapshots.
pub struct FileChangeTracker {
    root: std::path::PathBuf,
    snapshot: Option<FileSnapshot>,
}

/// A snapshot of file states.
#[derive(Debug, Clone)]
pub struct FileSnapshot {
    files: std::collections::HashMap<std::path::PathBuf, FileState>,
}

/// State of a single file.
#[derive(Debug, Clone)]
pub struct FileState {
    modified_at: std::time::SystemTime,
    size: u64,
}

impl FileChangeTracker {
    /// Create a new tracker.
    pub fn new(root: &Path) -> Self {
        Self {
            root: root.to_path_buf(),
            snapshot: None,
        }
    }

    /// Take a snapshot of current file states.
    pub async fn snapshot(&mut self) -> LoopResult<()> {
        let mut files = std::collections::HashMap::new();

        let mut entries = tokio::fs::read_dir(&self.root).await
            .map_err(|e| LoopError::FileSystemError { source: e })?;

        while let Some(entry) = entries.next_entry().await
            .map_err(|e| LoopError::FileSystemError { source: e })?
        {
            if let Ok(metadata) = entry.metadata().await {
                if metadata.is_file() {
                    files.insert(
                        entry.path(),
                        FileState {
                            modified_at: metadata.modified().unwrap_or(std::time::SystemTime::UNIX_EPOCH),
                            size: metadata.len(),
                        },
                    );
                }
            }
        }

        self.snapshot = Some(FileSnapshot { files });
        Ok(())
    }

    /// Detect changes since last snapshot.
    pub async fn detect_changes(&mut self) -> LoopResult<(
        Vec<std::path::PathBuf>,
        Vec<std::path::PathBuf>,
        Vec<std::path::PathBuf>,
    )> {
        let old_snapshot = match &self.snapshot {
            Some(s) => s.clone(),
            None => return Ok((vec![], vec![], vec![])),
        };

        // Take new snapshot
        self.snapshot().await?;

        let new_snapshot = self.snapshot.as_ref().unwrap();

        let mut modified = vec![];
        let mut created = vec![];
        let mut deleted = vec![];

        // Find modified and deleted files
        for (path, old_state) in &old_snapshot.files {
            match new_snapshot.files.get(path) {
                Some(new_state) => {
                    if new_state.modified_at != old_state.modified_at
                        || new_state.size != old_state.size
                    {
                        modified.push(path.clone());
                    }
                }
                None => {
                    deleted.push(path.clone());
                }
            }
        }

        // Find created files
        for path in new_snapshot.files.keys() {
            if !old_snapshot.files.contains_key(path) {
                created.push(path.clone());
            }
        }

        Ok((modified, created, deleted))
    }
}
```

### 3. Iteration History (src/iteration/history.rs)

```rust
//! Iteration history tracking.

use super::types::{Iteration, IterationResult, IterationStatus};
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use tokio::sync::RwLock;

/// Configuration for history retention.
#[derive(Debug, Clone)]
pub struct HistoryConfig {
    /// Maximum iterations to keep in memory.
    pub max_in_memory: usize,
    /// Whether to persist to disk.
    pub persist: bool,
    /// Path for persistence.
    pub persist_path: Option<std::path::PathBuf>,
}

impl Default for HistoryConfig {
    fn default() -> Self {
        Self {
            max_in_memory: 100,
            persist: true,
            persist_path: None,
        }
    }
}

/// Tracks iteration history.
pub struct IterationHistory {
    config: HistoryConfig,
    iterations: RwLock<VecDeque<Iteration>>,
    summary: RwLock<HistorySummary>,
}

/// Summary statistics of iteration history.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct HistorySummary {
    pub total_iterations: u32,
    pub successful_iterations: u32,
    pub failed_iterations: u32,
    pub timed_out_iterations: u32,
    pub total_duration_ms: u64,
    pub total_files_modified: u32,
    pub total_files_created: u32,
    pub total_tests_run: u32,
    pub total_tests_passed: u32,
    pub total_tests_failed: u32,
}

impl IterationHistory {
    /// Create a new history tracker.
    pub fn new(config: HistoryConfig) -> Self {
        Self {
            config,
            iterations: RwLock::new(VecDeque::new()),
            summary: RwLock::new(HistorySummary::default()),
        }
    }

    /// Add an iteration to history.
    pub async fn add(&self, iteration: Iteration) {
        let mut iterations = self.iterations.write().await;
        let mut summary = self.summary.write().await;

        // Update summary
        summary.total_iterations += 1;

        match iteration.status {
            IterationStatus::Completed => {
                summary.successful_iterations += 1;
                if let Some(result) = &iteration.result {
                    summary.total_duration_ms += result.duration_ms;
                    summary.total_files_modified += result.files_modified.len() as u32;
                    summary.total_files_created += result.files_created.len() as u32;

                    if let Some(tests) = &result.test_results {
                        summary.total_tests_run += tests.total;
                        summary.total_tests_passed += tests.passed;
                        summary.total_tests_failed += tests.failed;
                    }
                }
            }
            IterationStatus::Failed => {
                summary.failed_iterations += 1;
            }
            IterationStatus::TimedOut => {
                summary.timed_out_iterations += 1;
            }
            _ => {}
        }

        // Add to history
        iterations.push_back(iteration);

        // Trim if necessary
        while iterations.len() > self.config.max_in_memory {
            iterations.pop_front();
        }
    }

    /// Get the last N iterations.
    pub async fn get_last(&self, n: usize) -> Vec<Iteration> {
        let iterations = self.iterations.read().await;
        iterations.iter().rev().take(n).cloned().collect()
    }

    /// Get iteration by number.
    pub async fn get(&self, number: u32) -> Option<Iteration> {
        let iterations = self.iterations.read().await;
        iterations.iter().find(|i| i.number == number).cloned()
    }

    /// Get the current summary.
    pub async fn get_summary(&self) -> HistorySummary {
        self.summary.read().await.clone()
    }

    /// Get iterations matching a filter.
    pub async fn filter<F>(&self, predicate: F) -> Vec<Iteration>
    where
        F: Fn(&Iteration) -> bool,
    {
        let iterations = self.iterations.read().await;
        iterations.iter().filter(|i| predicate(i)).cloned().collect()
    }

    /// Get recent failure streak count.
    pub async fn get_failure_streak(&self) -> u32 {
        let iterations = self.iterations.read().await;
        let mut streak = 0;

        for iteration in iterations.iter().rev() {
            if iteration.status == IterationStatus::Failed
                || iteration.status == IterationStatus::TimedOut
            {
                streak += 1;
            } else if iteration.status == IterationStatus::Completed {
                break;
            }
        }

        streak
    }

    /// Persist history to disk.
    pub async fn persist(&self) -> Result<(), std::io::Error> {
        if !self.config.persist {
            return Ok(());
        }

        let path = match &self.config.persist_path {
            Some(p) => p.clone(),
            None => return Ok(()),
        };

        let iterations = self.iterations.read().await;
        let data = serde_json::to_string_pretty(&*iterations)?;
        tokio::fs::write(path, data).await
    }

    /// Load history from disk.
    pub async fn load(&self) -> Result<(), std::io::Error> {
        if !self.config.persist {
            return Ok(());
        }

        let path = match &self.config.persist_path {
            Some(p) => p.clone(),
            None => return Ok(()),
        };

        if !path.exists() {
            return Ok(());
        }

        let data = tokio::fs::read_to_string(path).await?;
        let loaded: VecDeque<Iteration> = serde_json::from_str(&data)?;

        let mut iterations = self.iterations.write().await;
        *iterations = loaded;

        Ok(())
    }
}
```

### 4. Module Root (src/iteration/mod.rs)

```rust
//! Iteration management for the Ralph loop.

pub mod executor;
pub mod history;
pub mod types;

pub use executor::{IterationConfig, IterationExecutor};
pub use history::{HistoryConfig, HistorySummary, IterationHistory};
pub use types::{
    Iteration, IterationResult, IterationStatus, TestDetail, TestResults, TestStatus,
};
```

---

## Testing Requirements

1. Iteration executes and captures output correctly
2. Timeout properly terminates long-running iterations
3. File change detection works accurately
4. Test output parsing handles multiple frameworks
5. Progress detection logic is accurate
6. History maintains correct size limits
7. Persistence saves and loads correctly
8. Failure streak calculation is accurate

---

## Related Specs

- Depends on: [096-loop-runner-core.md](096-loop-runner-core.md)
- Next: [098-prompt-loading.md](098-prompt-loading.md)
- Related: [106-test-failure-tracking.md](106-test-failure-tracking.md)

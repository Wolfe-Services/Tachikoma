//! Compliance framework support.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Supported compliance frameworks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ComplianceFramework {
    /// SOC 2 Type II.
    Soc2,
    /// ISO 27001.
    Iso27001,
    /// GDPR.
    Gdpr,
    /// HIPAA.
    Hipaa,
    /// PCI DSS.
    PciDss,
    /// Custom framework.
    Custom,
}

impl ComplianceFramework {
    /// Get framework display name.
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Soc2 => "SOC 2 Type II",
            Self::Iso27001 => "ISO 27001",
            Self::Gdpr => "GDPR",
            Self::Hipaa => "HIPAA",
            Self::PciDss => "PCI DSS",
            Self::Custom => "Custom",
        }
    }
}

/// A compliance control.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceControl {
    /// Control identifier (e.g., "CC6.1").
    pub id: String,
    /// Control name.
    pub name: String,
    /// Control description.
    pub description: String,
    /// Framework this control belongs to.
    pub framework: ComplianceFramework,
    /// Category within the framework.
    pub category: String,
    /// Audit event categories that provide evidence.
    pub evidence_categories: Vec<tachikoma_audit_types::AuditCategory>,
    /// Required actions for evidence.
    pub evidence_actions: Vec<String>,
}

/// Compliance evidence item.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceEvidence {
    /// Control this evidence supports.
    pub control_id: String,
    /// Type of evidence.
    pub evidence_type: EvidenceType,
    /// Description of the evidence.
    pub description: String,
    /// Related audit event IDs.
    pub event_ids: Vec<String>,
    /// Time range covered.
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    /// Event count.
    pub event_count: u64,
}

/// Type of compliance evidence.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EvidenceType {
    /// Audit log evidence.
    AuditLog,
    /// Configuration evidence.
    Configuration,
    /// Access control evidence.
    AccessControl,
    /// Change management evidence.
    ChangeManagement,
    /// Incident response evidence.
    IncidentResponse,
}

/// Control compliance status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ControlStatus {
    /// Control is fully compliant.
    Compliant,
    /// Control is partially compliant.
    PartiallyCompliant,
    /// Control is not compliant.
    NonCompliant,
    /// Not enough data to determine.
    Indeterminate,
    /// Not applicable.
    NotApplicable,
}

/// Compliance report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    /// Report identifier.
    pub id: String,
    /// Framework being reported on.
    pub framework: ComplianceFramework,
    /// Report title.
    pub title: String,
    /// Report period start.
    pub period_start: DateTime<Utc>,
    /// Report period end.
    pub period_end: DateTime<Utc>,
    /// Generated at.
    pub generated_at: DateTime<Utc>,
    /// Generated by.
    pub generated_by: String,
    /// Control assessments.
    pub controls: Vec<ControlAssessment>,
    /// Summary statistics.
    pub summary: ComplianceSummary,
}

/// Assessment of a single control.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ControlAssessment {
    /// Control being assessed.
    pub control: ComplianceControl,
    /// Assessment status.
    pub status: ControlStatus,
    /// Evidence collected.
    pub evidence: Vec<ComplianceEvidence>,
    /// Findings/notes.
    pub findings: Vec<String>,
    /// Recommendations.
    pub recommendations: Vec<String>,
}

/// Compliance summary.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceSummary {
    pub total_controls: u32,
    pub compliant: u32,
    pub partially_compliant: u32,
    pub non_compliant: u32,
    pub indeterminate: u32,
    pub not_applicable: u32,
    pub compliance_score: f64,
}

impl ComplianceSummary {
    /// Calculate summary from assessments.
    pub fn from_assessments(assessments: &[ControlAssessment]) -> Self {
        let mut summary = Self {
            total_controls: assessments.len() as u32,
            compliant: 0,
            partially_compliant: 0,
            non_compliant: 0,
            indeterminate: 0,
            not_applicable: 0,
            compliance_score: 0.0,
        };

        for assessment in assessments {
            match assessment.status {
                ControlStatus::Compliant => summary.compliant += 1,
                ControlStatus::PartiallyCompliant => summary.partially_compliant += 1,
                ControlStatus::NonCompliant => summary.non_compliant += 1,
                ControlStatus::Indeterminate => summary.indeterminate += 1,
                ControlStatus::NotApplicable => summary.not_applicable += 1,
            }
        }

        let applicable = summary.total_controls - summary.not_applicable;
        if applicable > 0 {
            let score = (summary.compliant as f64 + summary.partially_compliant as f64 * 0.5)
                / applicable as f64;
            summary.compliance_score = (score * 100.0).round();
        }

        summary
    }
}